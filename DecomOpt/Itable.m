function [D,an,an_] = Itable(A)
%% на входе
% A - матрица, описывающая двухвходовые блоки
% A(i,:)=[n n1 i1 n0 i0 a0 a1 a2 a3]
% n - номер блока
% n1, n0 - номера блоков старшего и млашего входов (входные переменные х1, х2, х4, ... отмечаются как -1 -2 -4...)
% i1, i0 - инверсность входов. 1 - неинверт. 0 - инверт
% a0 a1 a2 a3 - комбинация логической функции двухвходового блока
% Возможная часть f - уже существующие последовательности
%% на выходе:
% D - выходная матрица значений блоков с их выходными последовательностями
% an - последовательность блоков в порядке ярусов
% an_ - соответствующие ярусы
% Возвращает саму матрицу и разложение блоков на уровни
%%
D=A;
% D формируется как [D0; A D1];
% D0 - описание входных переменных
% D1 - выходные последовательности блоков
an=zeros(1,0); % блоки в порядке обхода
an_=zeros(1,0); % их соответствующие ярусы
%% Создание входных переменных
k_vh=abs(min([ min(D(:,2)) min(D(:,4))])); % поиск входной переменной с самым большим весом
k=1; 
D0=zeros(1,0);
while k<=k_vh % описание всех входных переменных от х1 до хk_vh
    x=[zeros(1,k_vh/k) ones(1,k_vh/k)]; %формирование повторяющейся части последовательности
    D0=[D0; -k_vh/k 0 0 0 0  0 0 0 0 repmat(x,1,k)]; % формирование строки матрицы 
    an=[an -k_vh/k]; % запись входных переменных в список блоков
    an_=[an_ 0]; % все входные переменнын расположены на нулевом ярусе
    k=k*2;
end
%%
%% НОВАЯ ЧАСТЬ
D0=[D0; zeros(1,9+k_vh*2)];  % константа! '0' 
an=[an 0];
an_=[an_ 0];
%%
%%
%% Создание матрицы
D=D(D(:,1)>0,:); % исключение уже описанных в D входных переменных
D=D(:,1:9); % очищение уже существующих выходных последовательностей
s=size(D,1); % размер изначальной матрицы D 
D1=zeros(s,k_vh*2); % заполнение выходных последовательностей блоков нулями

D=[D0; D D1]; % объединение в единую матрицу
s=size(D,1);
h=size(D,2);
%[s,h]=size(D); % размер новой матрицы
%% Заполнение выходных последовательностей 
ani=length(an); 
i=ani+1;
% вычисление выходных последовательностей до тех пор, пока все блоки не описаны в an
count=0;
while length(an)~=s  && count<1000
    count=count+1;
    hi=zeros(1,0);
    lo=zeros(1,0);
    for j=1:length(an)
        if an(j)==D(i,2)
            hi=[hi j];
        end
    end
    for j=1:length(an)
        if an(j)==D(i,4)% есть ли входы у блока, уже описаные в an
            lo=[lo j];
        end
    end
    if (isempty(hi)==0) % если оба входных блока уже описаны, то можно описать этот блок
        if (isempty(lo)==0)
            if (sum(D(i,10:h))==0) % проверка, что еще не описывали этот блок
                
                an=[an D(i,1)]; % добавляем его в последовательность блоков
                an_=[an_ max(an_(hi(:)),an_(lo(:)))+1]; % его ярус на один больше макстмального из ярусов входных блоков
                
                j=D(D(:,1)==D(i,2),:); % старший блок и его последовательность
                if D(i,3)==0 % проверка старшего блока на инверсность
                    j=Inve(j);
                end   
                k=D(D(:,1)==D(i,4),:); % младший блок и его последовательность
                if D(i,5)==0 % проверка младшего блока на инверсность
                    k=Inve(k);
                end
                
                % определение соответствующего выхода при подаче на вход пар чисел
                for d=10:h 
                    if j(d)==0
                        if k(d)==0
                            D(i,d)=D(i,6); %% комбинация 00 - a0
                        else
                            D(i,d)=D(i,7); %% комбинация 01 - a1
                        end
                    else
                        if k(d)==0
                            D(i,d)=D(i,8); %% комбинация 10 - a2
                        else
                            D(i,d)=D(i,9); %% комбинация 11 - a3
                        end
                    end
                end 
            end
        end
    end
    i=i+1; % изучение следующего блока
    if i>s
        i=ani+1; % снова рассматрение блоков матрицы A ( смещение на количество входных переменных)
    end
   
end

if count>=1000
    D=0;an=0;an_=0;
end
end


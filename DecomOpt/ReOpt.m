function D=ReOpt( D, An, an, an_, h_l)
%% Функция поиска возможной оптимизации
%% на входе
% D - вся матрица
% D(i,:)=[n n1 i1 n0 i0 a0 a1 a2 a3 f0_N]
% n - номер блока
% n1, n0 - номера блоков старшего и млашего входов (входные переменные х1, х2, х4, ... отмечаются как -1 -2 -4...)
% i1, i0 - инверсность входов. 1 - неинверт. 0 - инверт
% при этом nk ik - константа при значениях: 0 1 - '0' и 0 0 - '1'
% a0 a1 a2 a3 - комбинация логической функции двухвходового блока
% f0_N - выходная послеовательность
% An - рассматриваемый блок(строка из D)
% an - последовательность блоков в порядке ярусов
% an_ - ярусы последовательности блоков
% h_l - уровень фиксации (1 - старший, 0 - младший)
%% на выходе
% D со звездочками (звездочки = '-1')
%%
h=size(D,2); % размер матрицы

%% ТУТ ЭТО УСЛОВИЕ НОВОЕ "an_(an==An(1))>0"
 if an_(an==An(1))>0 % выход из рекурсии если дошел до 1 уровня

    if h_l==1  % старший вход фиксирован
        Fi=D(D(:,1)==An(2),:);  %Fi - старший вход
        if An(3)==0
            Fi=Inve(Fi); % его инверсия,если i1 = 0
        end
        NFi=D(D(:,1)==An(4),:);  %NFi - младший вход
        if An(5)==0
            NFi=Inve(NFi); % его инверсия,если i0 = 0
        end
        
        %g=find(An(10:length(An))<0); 
        %if g
        %    NFi(g+9)=-1; % * = '-1'
        %end
        for i=10:length(An)% замена на * NFi там, где An уже * 
            if An(i)==-1
                NFi(i)=-1;
            end
        end
       
        
        for d=10:h % замена на * тех NFi, где только Fi влияет на выход
            if (Fi(d)==0) && An(6)==An(7) && NFi(d)~=-1 % если a0=a1 при Fi=0
                NFi(d)=-1;
            elseif (Fi(d)==1) && An(8)==An(9) && NFi(d)~=-1 % если a2=a3 при Fi=1
                NFi(d)=-1;  
            end
        end
        
    else  % нижний вход фиксирован
        Fi=D(D(:,1)==An(4),:); %Fi - младший вход 
        if An(5)==0
            Fi=Inve(Fi); % его инверсия,если i0 = 0
        end
        NFi=D(D(:,1)==An(2),:);  %NFi - старший вход
        if An(3)==0
            NFi=Inve(NFi); % его инверсия,если i1 = 0
        end
        %g=find(An(10:h)<0); % замена на * NFi там, где An уже * 
        %if g
        %    NFi(g)=-1; % * = '-1'
        %end
        for i=10:h% замена на * NFi там, где An уже * 
            if An(i)==-1
                NFi(i)=-1;
            end
        end
    
        for d=10:h % замена на * тех NFi, где только Fi влияет на выход
            if (Fi(d)==0) && An(6)==An(8) && NFi(d)~=-1 % если a0=a2 при Fi=0
                NFi(d)=-1;
            elseif (Fi(d)==1) && An(7)==An(9) && NFi(d)~=-1 % если a1=a3 при Fi=1
                NFi(d)=-1;  
            end
        end
    end
%% после определения NFi вставляем ее на свое место в DAn 
    i=find(D(:,1)==NFi(1));
    DAn=D;
    if(NFi(1,1)>=0)
        DAn(i,:)=NFi;
    end;
    

%% 
    j=find(DAn(i,10:h)~=-1); % нашли все не * в NFi
    j=j+9;  

    if h_l==1 % hl - положение номера нефиксированого входа в последовательности описания блока
    	hl=4;
    else
    	hl=2;
    end
    %% НОВОЕ УСЛОВИЕ, В НЕГО ВХОДИТ СТАРЫЙ ЦИКЛ ПО ЭЛСЕ
    if sum(NFi(j))==length(j) % если это константа 1
        g= DAn(:,hl)==DAn(i,1); % определение строки в матрице, где лежит наш рассматриваемый блок
        DAn(g,hl)=0;
        DAn(g,hl+1)=0;
    elseif sum(NFi(j))==0 % если это константа 0
        g= DAn(:,hl)==DAn(i,1); % определение строки в матрице, где лежит наш рассматриваемый блок
        DAn(g,hl)=0;
        DAn(g,hl+1)=0;
    else
        %% ВОТ ТУТ ПОШЕЛ СТАРЫЙ ЦИКЛ
        
    for m=1:length(an) % поиск в цикле подходящей последовательности для замены
        if(D(m,j)==DAn(i,j))  % сравнение нужных элементов выходных последовательностей (не *)
            if m~=i
                k=m; % запоминание подходящей
                if an_(an==DAn(k,1))<=an_(an==DAn(i,1)) % проверка ярусности
                    g= DAn(:,hl)==DAn(i,1); % определение строки в матрице, где лежит наш рассматриваемый блок
                    DAn(g,hl)=DAn(k,1); % замена в матрице и рассматривыаемом блоке входа на подходящий
                    An(hl)=DAn(k,1);
                    break % принудительный выход вовне, не нужно искать другую замену
                end
            end
        else
        % аналогично проверяем для инвертированной последовательности
        A=D(m,:);
        A=Inve(A);
        D(m,:)=A;
        if(D(m,j)==DAn(i,j)) 
            if m~=i
                k=m;
                if an_(an==DAn(k,1))<=an_(an==DAn(i,1))
                    g=find(DAn(:,hl)==DAn(i,1));
                    DAn(g,hl)=DAn(k,1);
                    An(hl)=DAn(k,1);
                    DAn(g,hl+1)=0;
                    An(hl+1)=0;                    
                    break
                end
            end
        end
        % возвращаем обратно
        A= D(m,:);
        A=Inve(A);
        D(m,:)=A;
        end
    end
        %% ЗАКОНЧИЛСЯ СТАРЫЙ ЦИКЛ
    
    end; 
    %% КОНЕЦ НОВОГО УСЛОВИЯ
%% вызов рекурсии:
    i= D(:,1)==An(hl);
    An=DAn(i,:); %An включает в себя звездочки
    D=DAn; % D тоже
    D=ReOpt(D, An, an, an_, 1); %фиксируется старший вход
    D=ReOpt(D, An, an, an_, 0); %фиксируется младший вход
    
end

end


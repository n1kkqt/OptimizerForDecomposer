function [D, an, an_]= optim(D)
%% на входе
% D - матрица, описывающая двухвходовые блоки
% D(i,:)=[n n1 i1 n0 i0 a0 a1 a2 a3]
% n - номер блока
% n1, n0 - номера блоков старшего и млашего входов (входные переменные х1, х2, х4, ... отмечаются как -1 -2 -4... )
% i1, i0 - инверсность входов. 1 - неинверт. 0 - инверт
% при этом nk ik - константа при значениях: 0 1 - '0' и 0 0 - '1'
% a0 a1 a2 a3 - комбинация логической функции двухвходового блока
% Пример:
% D=[ 5 1 1 4 1 0 0 0 1;    4 2 1 3 1 0 0 0 1;    3 -8 1 -4 1 0 0 0 1;    2 -8 1 -4 1 0 0 0 1;    1 -2 1 -1 1 0 0 0 1];
%% на выходе
% D - матрица после оптимизации
%% 
% заполнение таблицы истинности
[D,an, an_]=Itable(D);
if length(an)>1
% функция возвращает D c выходными последовательностями f, порядок блоков an и их ярусы an_
h=size(D,2); % размеры итоговой матрицы
DAn=D; % запоминаем матрицу до оптимизации
An=D(D(:,1)==an(an_==max(an_)),:); 
% выбор последнего блока (блок максимального яруса) для дальнейшей процедуры оптимизации

% вызов функции поиска оптимизации с фиксированием старшего и младшего входов
D=ReOpt(D, An, an, an_, 1);
D=ReOpt(D, An, an, an_, 0);
% возвращает D с '*'

% проверка
[D11,~]=Itable(D);
% если итоговые выходные последовательности сошлись, то вывод матрицы D после сокращения лишних блоков
if DAn(DAn(:,1)==an(an_==max(an_)),10:h)==D11(D11(:,1)==an(an_==max(an_)),10:h)
    % вызов функции для сокращения всего подряд
    temp=an(an_==max(an_));
    D11=Oposled(D11,temp); % отправляется туда матрица и последний блок
    D=D11;
else 
    D=DAn;
end
[D,an,an_]=Itable(D);
if find(D(:,2)==0) 
    h=find(D(:,2)==0);
    for i=1:length(h) 
        if D(h(i),3)==1
            D(h(i),6:9)=[0 0 0 0];
        else
            D(h(i),6:9)=[1 1 1 1];
        end
        D(h(i),2)=1;
    end
end
if find(D(:,4)==0)
    h=find(D(:,4)==0);
    for i=1:length(h) 
        if D(h(i),5)==1
            D(h(i),6:9)=[0 0 0 0];
        else
            D(h(i),6:9)=[1 1 1 1];
        end
        D(h(i),4)=1;
    end
    

end
end

